// Generated by LiveScript 1.3.1
var react;
react = require('react/addons');
module.exports = {
  handleEnterKeyForSingleLineNormalText: function(selectionModel){
    var content, selectedNode, selectionIndex, newNode, removeConfig, config;
    content = this.state.content;
    selectedNode = selectionModel.nodes[0];
    selectionIndex = selectedNode.tagKey.split('.')[1] * 1;
    if (selectedNode.selectionStart === selectedNode.selectionEnd && selectedNode.selectionStart === selectedNode.node.innerText.length) {
      newNode = {
        tagName: 'p',
        nodeType: 1,
        childNodes: [{
          nodeType: 1,
          tagName: 'br',
          childNodes: []
        }]
      };
    } else {
      newNode = {
        tagName: 'p',
        nodeType: 1,
        childNodes: [{
          nodeType: 3,
          textContent: selectedNode.node.innerText.substring(selectedNode.selectionStart)
        }]
      };
      removeConfig = {};
      removeConfig[selectionIndex] = {
        childNodes: {
          0: {
            textContent: {
              $set: selectedNode.node.innerText.substring(0, selectedNode.selectionStart)
            }
          }
        }
      };
      config = {
        childNodes: removeConfig
      };
      content = react.addons.update(content, config);
    }
    config = {
      childNodes: {
        $splice: [[selectionIndex + 1, 0, newNode]]
      }
    };
    content = react.addons.update(content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    return this.updateState(content, content.childNodes[selectionIndex + 1].key, 0);
  },
  handleEnterKeyForSingleLineFormattedText: function(selectionModel, doReturn){
    var content, selectionNode, tagKeyArray, newNodes, selectedNodeIndex, c, config, topLevelParentIndex, topLevelParentNode, newTopLevelNode1, i$, to$, i, x, a, newTopLevelNode2, tagKey, selectionStart;
    content = this.state.content;
    selectionNode = selectionModel.nodes[0];
    tagKeyArray = selectionNode.tagKey.split('.').splice(1).map(function(item){
      return item * 1;
    });
    newNodes = this.splitNode(selectionNode.node, selectionNode.selectionStart);
    selectedNodeIndex = tagKeyArray.pop();
    c = {
      childNodes: {
        $splice: [[selectedNodeIndex, 1, newNodes[0], newNodes[1]]]
      }
    };
    config = tagKeyArray.reduceRight(this.buildConfigObject, c);
    content = react.addons.update(content, config);
    topLevelParentIndex = tagKeyArray.shift();
    topLevelParentNode = content.childNodes[topLevelParentIndex];
    c = {
      childNodes: {
        $splice: [[selectedNodeIndex + 1]]
      }
    };
    config = tagKeyArray.reduceRight(this.buildConfigObject, c);
    newTopLevelNode1 = react.addons.update(topLevelParentNode, config);
    for (i$ = 0, to$ = tagKeyArray.length - 2; i$ <= to$; ++i$) {
      i = i$;
      x = tagKeyArray[i];
      a = tagKeyArray.slice(0).splice(0, i + 1);
      c = {
        childNodes: {
          $splice: [[x + 1]]
        }
      };
      config = a.reduceRight(this.buildConfigObject, c);
      newTopLevelNode1 = react.addons.update(newTopLevelNode1, config);
    }
    c = {
      childNodes: {
        $splice: [[0, selectedNodeIndex + 1]]
      }
    };
    config = tagKeyArray.reduceRight(this.buildConfigObject, c);
    newTopLevelNode2 = react.addons.update(topLevelParentNode, config);
    for (i$ = 0, to$ = tagKeyArray.length - 1; i$ <= to$; ++i$) {
      i = i$;
      x = tagKeyArray[i];
      a = Array.apply(null, Array(i)).map(fn$);
      c = {
        childNodes: {
          $splice: [[0, x]]
        }
      };
      config = a.reduceRight(this.buildConfigObject, c);
      newTopLevelNode2 = react.addons.update(newTopLevelNode2, config);
    }
    if (doReturn) {
      return [newTopLevelNode1, newTopLevelNode2];
    }
    config = {
      childNodes: {
        $splice: [[topLevelParentIndex, 1, newTopLevelNode1, newTopLevelNode2]]
      }
    };
    content = react.addons.update(content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    tagKey = selectionNode.tagKey;
    selectionStart = selectionNode.selectionStart;
    return this.updateState(content, tagKey, selectionStart);
    function fn$(){
      return 0;
    }
  }
  /**
   * When user press enter on selection between multiline text:
   * 1. Delete text that is part of selection
   * @type {[type]}
   */,
  handleEnterKeyForMultilineNormalText: function(selectionModel){
    var content, selectionNodes, newNode1, newNode2, startIndex, endIndex, config, tagKey, selectionStart;
    content = this.state.content;
    selectionNodes = selectionModel.nodes;
    newNode1 = {
      tagName: selectionNodes[0].node.tagName.toLowerCase(),
      nodeType: 1,
      childNodes: [{
        nodeType: 3,
        textContent: selectionNodes[0].node.innerText.substring(0, selectionNodes[0].selectionStart)
      }]
    };
    newNode2 = {
      tagName: selectionNodes[1].node.tagName.toLowerCase(),
      nodeType: 1,
      childNodes: [{
        nodeType: 3,
        textContent: selectionNodes[1].node.innerText.substring(selectionNodes[1].selectionEnd)
      }]
    };
    startIndex = selectionNodes[0].tagKey.split('.')[1] * 1;
    endIndex = selectionNodes[1].tagKey.split('.')[1] * 1 - startIndex + 1;
    config = {
      childNodes: {
        $splice: [[startIndex, endIndex, newNode1, newNode2]]
      }
    };
    tagKey = selectionNodes[0].tagKey.split('.')[0] + '.' + (startIndex + 1);
    selectionStart = 0;
    content = react.addons.update(this.state.content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    return this.updateState(content, tagKey, selectionStart);
  },
  handleEnterKeyForMultilineFormattedText: function(selectionModel){
    var nodes, startIndex, endIndex, newNode1, newNode2, updatedSelectionModel, splittedNodes, config, content, tagKey, selectionStart;
    nodes = selectionModel.nodes;
    startIndex = nodes[0].tagKey.split('.')[1] * 1;
    endIndex = nodes[1].tagKey.split('.')[1] * 1;
    if (nodes[0].node.tagName.toLowerCase() === 'p') {
      newNode1 = this.splitNode(nodes[0].node, nodes[0].selectionStart)[0];
    }
    if (nodes[1].node.tagName.toLowerCase() === 'p') {
      newNode2 = this.splitNode(nodes[1].node, nodes[1].selectionEnd)[1];
    }
    if (!newNode1) {
      updatedSelectionModel = {
        nodes: [selectionModel.nodes[0]]
      };
      splittedNodes = this.handleEnterKeyForSingleLineFormattedText(updatedSelectionModel, true);
      newNode1 = splittedNodes[0];
      startIndex = nodes[0].tagKey.split('.')[1] * 1;
    }
    if (!newNode2) {
      updatedSelectionModel = {
        nodes: [selectionModel.nodes[1]]
      };
      updatedSelectionModel.nodes[0].selectionStart = selectionModel.nodes[1].selectionEnd;
      splittedNodes = this.handleEnterKeyForSingleLineFormattedText(updatedSelectionModel, true);
      newNode2 = splittedNodes[1];
    }
    config = {
      childNodes: {
        $splice: [[startIndex, endIndex - startIndex + 1, newNode1, newNode2]]
      }
    };
    content = react.addons.update(this.state.content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    tagKey = nodes[0].tagKey;
    selectionStart = nodes[0].selectionStart;
    return this.updateState(content, tagKey, selectionStart);
  },
  handleCharacterChangeForSingleLineNormalText: function(selectionModel, isAppending, character){
    var content, selectedNode, selectionStart, selectionEnd, selectionLength, tagKey, tagKeyArray, config, c;
    content = this.state.content;
    selectedNode = selectionModel.nodes[0];
    selectionStart = selectedNode.selectionStart;
    selectionEnd = selectedNode.selectionEnd;
    selectionLength = selectionEnd - selectionStart;
    tagKey = selectedNode.tagKey;
    tagKeyArray = tagKey.split('.').splice(1).map(function(item){
      return item * 1;
    });
    tagKeyArray.push(0);
    if (selectedNode.node.firstChild.tagName && selectedNode.node.firstChild.tagName.toLowerCase() === 'br') {
      if (character === 'Backspace' || character === 'Delete') {
        if (this.state.content.childNodes.length === 1) {
          return;
        }
        tagKeyArray.pop();
        config = {
          childNodes: {
            $splice: [[tagKeyArray[0], 1]]
          }
        };
        if (tagKeyArray[0] !== 0) {
          tagKey = 'root.' + (tagKeyArray[0] - 1);
          selectionStart = 'last-character';
        }
      } else {
        c = {
          textContent: {
            $set: character
          },
          nodeType: {
            $set: 3
          }
        };
        config = tagKeyArray.reduceRight(this.buildConfigObject, c);
        selectionStart += 1;
      }
    } else {
      if (selectedNode.node.firstChild.data.length === 1 && character === 'Backspace' || character === 'Delete') {
        c = {
          nodeType: {
            $set: 1
          },
          childNodes: {
            $set: []
          },
          tagName: {
            $set: 'br'
          }
        };
        config = tagKeyArray.reduceRight(this.buildConfigObject, c);
      } else {
        if (character === 'Backspace' && selectionStart === selectionEnd) {
          selectionStart -= 1;
        }
        config = tagKeyArray.reduceRight(this.buildConfigObject, isAppending
          ? this.appendText(character, selectionStart++, selectionLength)
          : this.deleteText(selectionStart, selectionLength));
      }
    }
    content = react.addons.update(this.state.content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    return this.updateState(content, tagKey, selectionStart);
  },
  handleCharacterChangeForSingleLineFormattedText: function(selectionModel, isAppending, character){
    var content, selectedNode, tagKey, tagKeyArray, parent, currentIndex, c, config, selectionStart;
    content = this.state.content;
    selectedNode = selectionModel.nodes[0];
    tagKey = selectedNode.tagKey;
    tagKeyArray = tagKey.split('.').splice(1).map(function(item){
      return item * 1;
    });
    tagKeyArray.push(0);
    parent = selectedNode.node.parentNode;
    currentIndex = tagKeyArray[tagKeyArray.length - 2];
    tagKeyArray = parent.getAttribute('data-tag-key').split('.').splice(1).map(function(item){
      return item * 1;
    });
    c = {
      childNodes: {
        $splice: [[currentIndex, 1]]
      }
    };
    config = tagKeyArray.reduceRight(this.buildConfigObject, c);
    content = react.addons.update(this.state.content, config);
    if (currentIndex !== 0) {
      tagKey = selectedNode.node.previousSibling.getAttribute('data-tag-key');
      selectionStart = selectedNode.node.previousSibling.firstChild.data.length;
    } else {
      tagKey = parent.parentNode.getAttribute('data-tag-key');
      selectionStart = 'last-character';
    }
    content = this.addKeysToTags(content, this.state.rootKey);
    return this.updateState(content, tagKey, selectionStart);
  },
  handleCharacterChangeForMultilineNormalText: function(selectionModel, isAppending, character){
    var content, selectionNodes, newNode, startIndex, endIndex, config, tagKey, selectionStart;
    content = this.state.content;
    selectionNodes = selectionModel.nodes;
    newNode = this.mergeNodes(selectionNodes, character);
    startIndex = selectionNodes[0].tagKey.split('.')[1] * 1;
    endIndex = selectionNodes[1].tagKey.split('.')[1] * 1 + 1;
    console.log(startIndex, endIndex);
    config = {
      childNodes: {
        $splice: [[startIndex, endIndex, newNode]]
      }
    };
    tagKey = selectionNodes[0].tagKey;
    selectionStart = character === 'Backspace' || character === 'Delete'
      ? selectionNodes[0].offset
      : selectionNodes[0].offset + 1;
    content = react.addons.update(this.state.content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    return this.updateState(content, tagKey, selectionStart);
  },
  handleCharacterChangeForMultilineFormattedText: function(selectionModel, isAppending, character){
    var nodes, startIndex, endIndex, newNode1, child, newNode2, updatedSelectionModel, splittedNodes, tagKeyArray, config, newNode, content, tagKey, selectionStart;
    console.warn('handle-character-change-for-multiline-formatted-text is not supported yet');
    nodes = selectionModel.nodes;
    startIndex = nodes[0].tagKey.split('.')[1] * 1;
    endIndex = nodes[1].tagKey.split('.')[1] * 1;
    if (nodes[0].node.tagName.toLowerCase() === 'p') {
      newNode1 = this.splitNode(nodes[0].node, nodes[0].selectionStart)[0];
      if (isAppending) {
        newNode1.childNodes[0].textContent += character;
      }
      child = newNode1.childNodes[0];
      newNode1.childNodes[0] = {
        tagName: 'span',
        nodeType: 1,
        childNodes: [child]
      };
    }
    if (nodes[1].node.tagName.toLowerCase() === 'p') {
      newNode2 = this.splitNode(nodes[1].node, nodes[1].selectionEnd)[1];
      child = newNode2.childNodes[0];
      newNode2.childNodes[0] = {
        tagName: 'span',
        nodeType: 1,
        childNodes: [child]
      };
    }
    if (!newNode1) {
      updatedSelectionModel = {
        nodes: [selectionModel.nodes[0]]
      };
      splittedNodes = this.handleEnterKeyForSingleLineFormattedText(updatedSelectionModel, true);
      newNode1 = splittedNodes[0];
      if (isAppending) {
        tagKeyArray = nodes[0].tagKey.split('.').slice(2).map(function(item){
          return item * 1;
        });
        tagKeyArray.push(0);
        config = tagKeyArray.reduceRight(this.buildConfigObject, this.appendText(character, nodes[0].selectionStart));
        newNode1 = react.addons.update(newNode1, config);
      }
    }
    if (!newNode2) {
      updatedSelectionModel = {
        nodes: [selectionModel.nodes[1]]
      };
      updatedSelectionModel.nodes[0].selectionStart = selectionModel.nodes[1].selectionEnd;
      splittedNodes = this.handleEnterKeyForSingleLineFormattedText(updatedSelectionModel, true);
      newNode2 = splittedNodes[1];
    }
    newNode = {
      tagName: 'p',
      nodeType: 1,
      childNodes: newNode1.childNodes.concat(newNode2.childNodes)
    };
    config = {
      childNodes: {
        $splice: [[startIndex, endIndex - startIndex + 1, newNode]]
      }
    };
    content = react.addons.update(this.state.content, config);
    content = this.addKeysToTags(content, this.state.rootKey);
    tagKey = nodes[0].tagKey;
    selectionStart = nodes[0].selectionStart;
    if (isAppending) {
      selectionStart++;
    }
    return this.updateState(content, tagKey, selectionStart);
  },
  handleCharacterChange: function(isAppending, character){
    var selectionModel, content;
    selectionModel = this.getSelectionModel();
    content = this.state.content;
    console.log(selectionModel);
    if (selectionModel.multilineSelection) {
      if (selectionModel.normalTextOnly) {
        return this.handleCharacterChangeForMultilineNormalText(selectionModel, isAppending, character);
      } else {
        return this.handleCharacterChangeForMultilineFormattedText(selectionModel, isAppending, character);
      }
    } else {
      if (selectionModel.normalTextOnly || isAppending || selectionModel.nodes[0].node.firstChild.data.length !== 1) {
        return this.handleCharacterChangeForSingleLineNormalText(selectionModel, isAppending, character);
      } else {
        return this.handleCharacterChangeForSingleLineFormattedText(selectionModel, isAppending, character);
      }
    }
  },
  buildConfigObject: function(pre, cur){
    var obj;
    obj = {
      childNodes: {}
    };
    obj.childNodes[cur] = pre;
    return obj;
  },
  appendText: function(character, position, length){
    position = position === 0
      ? 0
      : position || currentValue.length;
    length = length || 0;
    return {
      textContent: {
        $apply: function(currentValue){
          currentValue = (currentValue || '').split('');
          if (currentValue.length === 0) {
            currentValue.push(character);
          } else {
            currentValue.splice(position, length, character);
          }
          return currentValue.join('');
        }
      }
    };
  },
  deleteText: function(start, length){
    length = length || 1;
    return {
      textContent: {
        $apply: function(currentValue){
          currentValue = currentValue.split('');
          currentValue.splice(start, length);
          return currentValue.join('');
        }
      }
    };
  },
  mergeNodes: function(nodes, character){
    var textFirst, textSecond, newNode;
    if (character === 'Backspace' || character === 'Delete') {
      character = '';
    }
    textFirst = nodes[0].node.firstChild.data.substring(0, nodes[0].offset);
    textSecond = nodes[1].node.firstChild.data.substring(nodes[1].offset);
    return newNode = {
      tagName: nodes[1].node.tagName.toLowerCase(),
      nodeType: 1,
      childNodes: [{
        nodeType: 3,
        textContent: textFirst + character + textSecond
      }]
    };
  },
  splitNode: function(node, splitPosition){
    var nodes;
    nodes = [];
    nodes.push({
      tagName: node.tagName.toLowerCase(),
      nodeType: 1,
      childNodes: [{
        nodeType: 3,
        textContent: node.innerText.substring(0, splitPosition)
      }]
    });
    nodes.push({
      tagName: node.tagName.toLowerCase(),
      nodeType: 1,
      childNodes: [{
        nodeType: 3,
        textContent: node.innerText.substring(splitPosition)
      }]
    });
    return nodes;
  }
};