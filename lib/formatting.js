// Generated by LiveScript 1.3.1
var react;
react = require('react/addons');
module.exports = {
  applyBoldFormat: function(){
    return this.applyFormat('b');
  },
  applyItalicFormat: function(){
    return this.applyFormat('i');
  },
  applyUnderlineFormat: function(){
    return this.applyFormat('u');
  },
  applyStriketroughFormat: function(){
    return this.applyFormat('del');
  },
  applyFormat: function(formatTag){
    var selectionModel, content, selectedNode, selectionStart, selectionEnd, tagName, text, tagKey, tagKeyArray, spliceArray, formatPosition, newFormattedNode, c, newNode, config, index, selectionElTagKey, newNodeOne, boldPosition, newNodeTwo, mergeConfig;
    selectionModel = this.getSelectionModel();
    content = this.state.content;
    if (selectionModel.type === 'Caret') {
      return console.warn('Caret selection type is not supported yet');
    } else {
      if (selectionModel.multilineSelection) {
        return console.log('multiline selection');
      } else {
        selectedNode = selectionModel.nodes[0];
        selectionStart = selectedNode.selectionStart;
        selectionEnd = selectedNode.selectionEnd;
        tagName = selectedNode.node.tagName.toLowerCase();
        text = selectedNode.node.firstChild.data;
        tagKey = selectedNode.tagKey;
        tagKeyArray = tagKey.split('.').splice(1).map(function(item){
          return item * 1;
        });
        spliceArray = [0, 1];
        formatPosition = 0;
        newFormattedNode = {
          tagName: formatTag,
          nodeType: 1,
          childNodes: [{
            nodeType: 3,
            textContent: text.substring(selectionStart, selectionEnd)
          }]
        };
        if (tagName === 'span') {
          console.log(tagKey);
          if (selectionStart === 0 && selectionEnd === text.length) {
            c = {
              tagName: {
                $set: formatTag
              }
            };
          } else {
            if (selectionStart === 0) {
              c = {
                tagName: {
                  $set: formatTag
                },
                childNodes: {
                  0: {
                    textContent: {
                      $set: text.substring(0, selectionEnd)
                    }
                  }
                }
              };
              newNode = {
                tagName: 'span',
                nodeType: 1,
                childNodes: [{
                  nodeType: 3,
                  textContent: text.substring(selectionEnd)
                }]
              };
              config = tagKeyArray.reduceRight(this.buildConfigObject, c);
              content = react.addons.update(content, config);
              index = tagKeyArray.pop();
              c = {
                childNodes: {
                  $splice: [[index + 1, 0, newNode]]
                }
              };
            } else if (selectionEnd === text.length) {
              c = {
                tagName: {
                  $set: formatTag
                },
                childNodes: {
                  0: {
                    textContent: {
                      $set: text.substring(selectionStart)
                    }
                  }
                }
              };
              newNode = {
                tagName: 'span',
                nodeType: 1,
                childNodes: [{
                  nodeType: 3,
                  textContent: text.substring(0, selectionStart)
                }]
              };
              config = tagKeyArray.reduceRight(this.buildConfigObject, c);
              content = react.addons.update(content, config);
              index = tagKeyArray.pop();
              c = {
                childNodes: {
                  $splice: [[index, 0, newNode]]
                }
              };
              selectionElTagKey = 'root.' + tagKeyArray.join('.') + '.' + (index + 1);
              console.log(selectionElTagKey);
            } else {
              c = {
                tagName: {
                  $set: formatTag
                },
                childNodes: {
                  0: {
                    textContent: {
                      $set: text.substring(selectionStart, selectionEnd)
                    }
                  }
                }
              };
              newNode = {
                tagName: 'span',
                nodeType: 1,
                childNodes: [{
                  nodeType: 3,
                  textContent: text.substring(0, selectionStart)
                }]
              };
              config = tagKeyArray.reduceRight(this.buildConfigObject, c);
              content = react.addons.update(content, config);
              index = tagKeyArray.pop();
              c = {
                childNodes: {
                  $splice: [[index, 0, newNode]]
                }
              };
              newNode = {
                tagName: 'span',
                nodeType: 1,
                childNodes: [{
                  nodeType: 3,
                  textContent: text.substring(selectionEnd)
                }]
              };
              config = tagKeyArray.reduceRight(this.buildConfigObject, c);
              content = react.addons.update(content, config);
              c = {
                childNodes: {
                  $splice: [[index + 2, 0, newNode]]
                }
              };
              selectionElTagKey = 'root.' + tagKeyArray.join('.') + '.' + (index + 1);
              console.log(selectionElTagKey);
            }
          }
        } else {
          if (selectionStart !== 0) {
            newNodeOne = {
              tagName: 'span',
              nodeType: 1,
              childNodes: [{
                nodeType: 3,
                textContent: text.substring(0, selectionStart)
              }]
            };
            boldPosition = 1;
            spliceArray.push(newNodeOne);
            spliceArray.push(newFormattedNode);
            if (selectionEnd !== text.length) {
              newNodeTwo = {
                tagName: 'span',
                nodeType: 1,
                childNodes: [{
                  nodeType: 3,
                  textContent: text.substring(selectionEnd)
                }]
              };
              spliceArray.push(newNodeTwo);
            }
          } else {
            spliceArray.push(newFormattedNode);
            if (selectionEnd !== text.length) {
              newNodeTwo = {
                tagName: 'span',
                nodeType: 1,
                childNodes: [{
                  nodeType: 3,
                  textContent: text.substring(selectionEnd)
                }]
              };
              spliceArray.push(newNodeTwo);
            }
          }
          c = {
            childNodes: {
              $splice: [spliceArray]
            }
          };
          selectionElTagKey = 'root.' + tagKeyArray.join('.') + '.' + boldPosition;
        }
        config = tagKeyArray.reduceRight(this.buildConfigObject, c);
        content = react.addons.update(content, config);
        content = this.addKeysToTags(content, this.state.rootKey);
        mergeConfig = this.mergeSiblingsFormattingNodes(content);
        if (mergeConfig) {
          console.log(mergeConfig);
        }
        return this.updateState(content, selectionElTagKey, selectionEnd - selectionStart);
      }
    }
  },
  mergeSiblingsFormattingNodes: function(content){
    var i$, ref$, len$, x, availableNodesForMerge, j$, to$, i, newNode, this$ = this;
    for (i$ = 0, len$ = (ref$ = content.childNodes).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x.nodeType === 3) {
        return;
      }
      this.mergeSiblingsFormattingNodes(x);
      availableNodesForMerge = x.childNodes.map(fn$);
      for (j$ = 0, to$ = x.childNodes.length - 2; j$ <= to$; ++j$) {
        i = j$;
        if (availableNodesForMerge[i] && availableNodesForMerge[i + 1] && x.childNodes[i].tagName === x.childNodes[i + 1].tagName) {
          newNode = this.tryMerge(x.childNodes[i], x.childNodes[i + 1]);
          return {
            parentNode: x,
            index: i,
            newNode: newNode
          };
        }
      }
    }
    function fn$(node){
      return this$.isPossibleNodeForMerge(node);
    }
  },
  isPossibleNodeForMerge: function(node){
    if (node.nodeType === 1 && node.childNodes.length === 1 && node.childNodes[0].nodeType === 3) {
      return true;
    } else {
      return false;
    }
  },
  tryMerge: function(node1, node2){
    console.log('trying to merge: ', node1.childNodes[0].textContent, node2.childNodes[0].textContent);
    return {
      nodeType: 1,
      tagName: node1.tagName,
      childNodes: [{
        nodeType: 3,
        textContent: node1.childNodes[0].textContent + node2.childNodes[0].textContent
      }]
    };
  }
};